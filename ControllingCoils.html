<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLUXza5VhXqVC6o75Eld_V98);.lst-kix_list_2-6>li:before{content:"\0025cf   "}.lst-kix_list_2-7>li:before{content:"o  "}ul.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_2-4>li:before{content:"o  "}.lst-kix_list_2-5>li:before{content:"\0025aa   "}.lst-kix_list_2-8>li:before{content:"\0025aa   "}.lst-kix_list_3-0>li:before{content:"-  "}.lst-kix_list_3-1>li:before{content:"o  "}.lst-kix_list_3-2>li:before{content:"\0025aa   "}ul.lst-kix_list_3-7{list-style-type:none}ul.lst-kix_list_3-8{list-style-type:none}ul.lst-kix_list_1-3{list-style-type:none}ul.lst-kix_list_3-1{list-style-type:none}.lst-kix_list_3-5>li:before{content:"\0025aa   "}ul.lst-kix_list_1-4{list-style-type:none}ul.lst-kix_list_3-2{list-style-type:none}ul.lst-kix_list_1-1{list-style-type:none}.lst-kix_list_3-4>li:before{content:"o  "}ul.lst-kix_list_1-2{list-style-type:none}ul.lst-kix_list_3-0{list-style-type:none}ul.lst-kix_list_1-7{list-style-type:none}.lst-kix_list_3-3>li:before{content:"\0025cf   "}ul.lst-kix_list_3-5{list-style-type:none}ul.lst-kix_list_1-8{list-style-type:none}ul.lst-kix_list_3-6{list-style-type:none}ul.lst-kix_list_1-5{list-style-type:none}ul.lst-kix_list_3-3{list-style-type:none}ul.lst-kix_list_1-6{list-style-type:none}ul.lst-kix_list_3-4{list-style-type:none}.lst-kix_list_3-8>li:before{content:"\0025aa   "}.lst-kix_list_3-6>li:before{content:"\0025cf   "}.lst-kix_list_3-7>li:before{content:"o  "}ul.lst-kix_list_2-8{list-style-type:none}ul.lst-kix_list_2-2{list-style-type:none}.lst-kix_list_1-0>li:before{content:"-  "}ul.lst-kix_list_2-3{list-style-type:none}ul.lst-kix_list_2-0{list-style-type:none}ul.lst-kix_list_2-1{list-style-type:none}ul.lst-kix_list_2-6{list-style-type:none}.lst-kix_list_1-1>li:before{content:"o  "}.lst-kix_list_1-2>li:before{content:"\0025aa   "}ul.lst-kix_list_2-7{list-style-type:none}ul.lst-kix_list_2-4{list-style-type:none}ul.lst-kix_list_2-5{list-style-type:none}.lst-kix_list_1-3>li:before{content:"\0025cf   "}.lst-kix_list_1-4>li:before{content:"o  "}.lst-kix_list_1-7>li:before{content:"o  "}.lst-kix_list_1-5>li:before{content:"\0025aa   "}.lst-kix_list_1-6>li:before{content:"\0025cf   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_list_2-0>li:before{content:"-  "}.lst-kix_list_2-1>li:before{content:"o  "}.lst-kix_list_1-8>li:before{content:"\0025aa   "}.lst-kix_list_2-2>li:before{content:"\0025aa   "}.lst-kix_list_2-3>li:before{content:"\0025cf   "}ol{margin:0;padding:0}table td,table th{padding:0}.c11{color:#2f5496;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Calibri";font-style:normal}.c15{padding-top:12pt;padding-bottom:12pt;line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Calibri";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Courier New";font-style:normal}.c7{padding-top:2pt;padding-bottom:12pt;line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left;height:11pt}.c6{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Calibri";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;height:11pt}.c10{padding-top:12pt;padding-bottom:0pt;line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c16{color:#2f5496;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Calibri";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c5{padding-top:0pt;padding-bottom:8pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left}.c2{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#0563c1;text-decoration:underline}.c19{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c9{color:inherit;text-decoration:inherit}.c4{margin-left:36pt;padding-left:0pt}.c14{padding:0;margin:0}.c18{height:11pt}.c17{margin-right:-28.1pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0791666666666666;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Calibri"}p{margin:0;color:#000000;font-size:11pt;font-family:"Calibri"}h1{padding-top:12pt;color:#2f5496;font-size:16pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:2pt;color:#2f5496;font-size:13pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:2pt;color:#1f3863;font-size:12pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c19 doc-content"><h1 class="c10"><span class="c16">Controlling Coils</span></h1><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The P3 SDK shows how to activate a coil in the Drivers section of P3_SDK_V0.8/P3SampleApp/Documentation/html/_physical_features.html</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The coil is an instance of the Driver class documented in P3_SDK_V0.8/P3SampleApp/Documentation/html/class_multimorphic_1_1_net_proc_machine_1_1_machine_1_1_driver.html</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The Driver class can also control flashers, motors, shakers and similar devices.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">We will be exploring the Driver methods in more detail.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">Disclaimer: this information was tested with a P-ROC before I received my P3 machine.</span></p><h2 class="c15"><span class="c11">Preferred Architecture</span></h2><p class="c3"><span class="c1">Multimorphic suggests an architecture where the module driver exposes a high-level API to control the mechs. The application never calls the drivers directly, instead it sends events to the module driver to control the mechs.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">Take a look at the module driver documentation to learn which events are available. For example, Heist has events to control the crane. Take advantage of these events to leverage all the logic implemented in the module driver.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">So why bother learning how to control drivers directly? You might have to call the drivers directly for flashers. Maybe you need a work-around for a gap of functionality in the module driver (ball search maybe). You might have to write a module driver one day. Finally, it&rsquo;s always good to know how it works under the hood.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">P3Controller Coils</span></h2><p class="c5"><span class="c1">The list of coils consists of the coils in the base machine plus the coils in the installed module. The list of coils in the base machine is built-in to the SDK. The list of coils in the module comes from the Coils section of the module definition file. In the simulator, that file is here ~/.multimorphic/P3/ModuleDrivers/&lt;moduleName&gt;/&lt;moduleVersion&gt;/&lt;moduleName&gt;.json</span></p><p class="c5"><span class="c1">The P3Controller instance stores the list of coils in an AttrCollection named Coils. Within a mode, you can access a specific coil with p3.Coils[&quot;coilName&quot;]</span></p><h2 class="c7"><span class="c11">Enable Method</span></h2><p class="c12"><span class="c1">You can activate a coil forever with the Enable method.</span></p><p class="c5"><span class="c13">public void Enable()</span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].Enable()</span></p><p class="c8"><span class="c1"></span></p><p class="c12"><span class="c1">This is common to do for a flipper hold coil, but this can be a bad idea in other contexts. The application might be careful to deactivate the coil, but if something goes wrong, the coil could overheat. Whenever possible, it is better to enforce a time limit in the activation itself or use pulse width modulation to lower the power as described later.</span></p><h2 class="c15"><span class="c11">Disable Method</span></h2><p class="c12"><span class="c1">You can deactivate a coil with the Disable method.</span></p><p class="c5"><span class="c13">public void Disable()</span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].Disable()</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">It is perfectly fine to disable a coil that is already disabled.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">Default Pulse Method</span></h2><p class="c3"><span class="c1">You can activate a coil with the Pulse method.</span></p><p class="c3"><span class="c13">public void Pulse()</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].Pulse()</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">This will activate the coil for the default pulse time in milliseconds. The default pulse time is accessible with the property p3.Coils[&quot;coilName&quot;].DefaultPulseTime. The property data type is int but the value is constrained to a byte (0 to 255) in the set accessor.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The default pulse time is initialized from the PulseTime field in the module definition file. For flippers and bumpers, the default pulse time comes from a GameAttribute (i.e. a settings in the service menu). The settings name is declared in the module definition file:</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &quot;Flippers&quot;: [</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Name&quot;: &quot;flipperUpR&quot;,</span></p><p class="c3"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">&quot;SettingPrefix&quot;: &quot;UpperRightFlipper&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;SwitchName&quot;: &quot;buttonRight2&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;SecondarySwitchName&quot;: &quot;buttonLeft2&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;AlternateSwitchName&quot;: &quot;buttonRight0&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;MainCoilName&quot;: &quot;auxRight0&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;HoldCoilName&quot;: &quot;auxRight1&quot;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; ],</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &quot;Bumpers&quot;: [</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Name&quot;: &quot;popBumper&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;SwitchName&quot;: &quot;popBumper&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;CoilName&quot;: &quot;popBumper&quot;,</span></p><p class="c3"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">&quot;SettingName&quot;: &quot;popBumperStrength&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;SwitchPolarity&quot;: true,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;AllowShotgunning&quot;: true</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; ],</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &quot;Coils&quot;: [</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Name&quot;: &quot;dropTargetReset&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Number&quot;: &quot;A6-B0-1&quot;,</span></p><p class="c3"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;PulseTime&quot;: &quot;30&quot;,</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Label&quot;: &quot;Drop Target Reset&quot;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; },</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">A module driver can choose to initialize the default pulse time from a settings for other coils as well. This is module dependent.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">I simplified a little because the settings is often a strength value and not a pulse time. The value maps to a table of patter patterns sorted in increasing power. This is one of the advantages you get by letting the module driver pulse the coil for you. More on patter below.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">Pulse Method</span></h2><p class="c3"><span class="c1">You can activate a coil for a specific time by calling the Pulse method with an argument.</span></p><p class="c3"><span class="c13">public void Pulse(int milliseconds)</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].Pulse(30)</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">When milliseconds &lt; 0, this activates the coil for the default pulse time.</span></p><p class="c3"><span class="c1">When milliseconds == 0, this activates the coil forever. Be careful with that.</span></p><p class="c3"><span class="c1">When milliseconds &lt;= 255, this activates the coil for that many milliseconds.</span></p><p class="c3"><span class="c1">When milliseconds &gt; 255, this throws ArgumentOutOfRangeException.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The Pulse() method with no arguments is equivalent to Pulse(-1)</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The Enable() method is equivalent to Pulse(0)</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">FuturePulse Method</span></h2><p class="c3"><span class="c1">You can activate a coil after a time delay with the FuturePulse method.</span></p><p class="c3"><span class="c13">public void FuturePulse(int milliseconds, UInt16 futureTime)</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].FuturePulse(30, 500)</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The milliseconds argument behaves like in the Pulse method.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span>The </span><span class="c2"><a class="c9" href="https://www.google.com/url?q=https://github.com/preble/libpinproc/blob/dev/include/pinproc.h%23L584&amp;sa=D&amp;source=editors&amp;ust=1692930752138565&amp;usg=AOvVaw3psqLfH0L6oqvYXZzqlyTK">C header in libpinproc</a></span><span class="c1">&nbsp;describes the futureTime argument as: &ldquo;The value at which hardware timestamp the pulse should occur. &nbsp;Currently only the low 10-bits are used.&rdquo; The value is taken modulo 1024 so the effective range is from 0 to 1023. The hardware timestamp appears to wrap around after approximately 1 second, so each unit of futureTime is close to 1 millisecond.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The coil is activated when the hardware timestamp is equal to futureTime. Said another way, the coil is activated at a time relative to a one second internal clock plus an offset. This could be very soon from now, or up to 1 second for any value of futureTime.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">When the coil is already activated, this method does not appear to deactivate the coil while waiting for the futureTime to match.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">See the Schedule() method for an easier API to use.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">Patter Method</span></h2><p class="c3"><span class="c1">Activating a coil for a long time heats the coil, making the coil weaker and possibly leads to permanent damage. A better approach is to activate and deactivate the coil repeatedly in quick succession such that the coil is energized only a fraction of the time. This technique is called Pulse Width Modulation or PWM.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The application can try to do this by enabling and disabling the coil explicitly but with the USB latency, the time resolution is coarse and not uniform. A better way is to let the P3-ROC take care of PWM at 1 millisecond resolution without network traffic.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">You can activate a coil with PWM with the Patter method.</span></p><p class="c5 c17"><span class="c13">public void Patter(ushort on_time, ushort off_time, ushort orig_on_time)</span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].Patter(2, 8, 12)</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The values of on_time, off_time and orig_on_time must be between 0 and 255 inclusive, otherwise this throws ArgumentOutOfRangeException.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">If orig_on_time is 0, this will repeatedly enable the coil for on_time milliseconds and disable it for off_time milliseconds. For Patter(a,b,0), you get a,b,a,b,&hellip;</span></p><p class="c3"><span class="c1">If orig_on_time is greater than 0, this will activate the coil for orig_on_time milliseconds, then it will repeatedly disable the coil for off_time milliseconds and enable it for on_time milliseconds. For Patter(a,b,c) you get c,b,a,b,a,&hellip; &nbsp;The documentation suggests c,a,b,a,b&hellip; but that&rsquo;s not what happens.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The orig_on_time is convenient for single-winded flipper coils where the full power is needed to flip but only minimal PWM power is needed to hold the flipper up. Similarly, a shaker might need full power to start the motor spinning and then only minimal PWM power to keep spinning.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The coil continues to patter until it is explicitly disabled.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">PulsedPatter Method</span></h2><p class="c3"><span class="c1">You can activate a coil with PWM for a specific runtime with the PulsedPatter method.</span></p><p class="c5 c17"><span class="c13">public void PulsedPatter(ushort on_time, ushort off_time, ushort run_time)</span></p><p class="c3"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].PulsedPatter(2, 8, 128)</span></p><p class="c3"><span class="c1">The values of on_time, off_time must be between 0 and 127 inclusive, otherwise this throws ArgumentOutOfRangeException. The 127 maximum is less than the 255 maximum in the Patter method.</span></p><p class="c3"><span class="c1">The value of run_time must be between 0 and 255 inclusive, otherwise this throws ArgumentOutOfRangeException.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">This will repeatedly activate the coil for on_time milliseconds and deactivate the coil for off_time milliseconds. This ends after run_time milliseconds.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">See the Schedule() method for the possibility to patter a coil for longer albeit with a coarser time resolution.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">Schedule Method</span></h2><p class="c3"><span class="c1">You can activate a coil according to a one second schedule with the Schedule method.</span></p><p class="c12"><span class="c13">public void Schedule(uint schedule, int cycle_seconds)</span></p><p class="c5"><span class="c13">public void Schedule(uint schedule, int cycle_seconds, bool now)</span></p><p class="c5"><span class="c1">For example: p3.Coils[&quot;coilName&quot;].Schedule(0x11F, 1, true)</span></p><p class="c5"><span>The call Schedule(millis, secs) is equivalent to Schedule(millis, secs, true). </span></p><p class="c3"><span class="c1">The schedule is a 32-bit mask. Each bit represents a 1/32 second timeslot with the least-significant bit coming first and the most-significant bit coming last. The coil is activated for the timeslot if the corresponding bit is 1, otherwise the coil is deactivated for that timeslot.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">This can achieve a pulse longer than 255 milliseconds which is the maximum with Pulse(int).</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">If now is true, the schedule starts immediately. If now is false, the coil is deactivated until an internal one second boundary is reached, and then the schedule starts. Given multiple coils scheduled with now=false, they will all synchronize on the same boundary, though the synchronization might take up to a full second to get going.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">The cycle_seconds argument is the integer number of seconds the schedule will run. Since the schedule lasts one second, this is how many times the schedule will run. The schedule runs forever if cycle_seconds is 0. To achieve schedules shorter than 1 second, set the most-significant bits to 0 and set cycle_seconds to 1. </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">To activate a coil for 128 milliseconds, then wait 64 milliseconds and activate for another 64 milliseconds, use the schedule 0b11001111. Binary literals are not available in the C# version used by the P3 SDK, so use hex instead. If the schedule does not repeat, you get: Schedule(0xCF, 1, true). </span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">To achieve a pulse which is a multiple number of seconds use Schedule(0xffffffff, secs, true).</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">FuturePulse(milliseconds, futureTime) can be emulated with Schedule(schedule, 1, false) at a resolution of 1/32 of a second. To compute the schedule, divide milliseconds by 32, this is how many bits to set in the schedule. For example, if milliseconds is 130, we need to set 4 bits, which gives 0xf.</span></p><p class="c0"><span class="c1"></span></p><h2 class="c7"><span class="c11">Appendix 1 libpinproc</span></h2><p class="c3"><span class="c1">The Driver class exists in the netproc DLL. This DLL is a .NET wrapper over the C++ library libpinproc.</span></p><p class="c0"><span class="c1"></span></p><p class="c5"><span>You can take a look at the </span><span class="c2"><a class="c9" href="https://www.google.com/url?q=https://github.com/preble/libpinproc&amp;sa=D&amp;source=editors&amp;ust=1692930752144743&amp;usg=AOvVaw0Ndf19fI-iRzVzWqNhpb3O">libpinproc source code</a></span><span class="c1">&nbsp;if you are interested in the low-level details.</span></p><p class="c5"><span>The </span><span class="c2"><a class="c9" href="https://www.google.com/url?q=https://github.com/preble/libpinproc/blob/dev/include/pinproc.h%23L567&amp;sa=D&amp;source=editors&amp;ust=1692930752145167&amp;usg=AOvVaw1ut21UxP1RziNKMlTxfpqi">libpinproc header file</a></span><span class="c1">&nbsp;contains some interesting documentation for the Driver functions, which I tried to summarize above. This file also defines the structure for the Driver state. This structure explains many of the range limits in the Driver methods.</span></p><p class="c3"><span class="c1">typedef struct PRDriverState {</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; uint16_t driverNum;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; uint8_t outputDriveTime;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; bool_t polarity;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; bool_t state;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; bool_t waitForFirstTimeSlot;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; uint32_t timeslots;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; uint8_t patterOnTime;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; uint8_t patterOffTime;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; bool_t patterEnable;</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; bool_t futureEnable;</span></p><p class="c3"><span class="c1">} PRDriverState;</span></p><p class="c5 c18"><span class="c1"></span></p><h2 class="c7"><span class="c11">Appendix 2 pypinproc</span></h2><p class="c3"><span class="c2"><a class="c9" href="https://www.google.com/url?q=https://github.com/preble/pypinproc&amp;sa=D&amp;source=editors&amp;ust=1692930752146329&amp;usg=AOvVaw0FUP9hLV5mw-3Pg-XIfVIC">pypinproc</a></span><span class="c1">&nbsp;is a Python wrapper over libpinproc. It can be considered an ancestor cousin of netproc.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span>pypinproc is not directly relevant to P3 programming. I&rsquo;m mentioning pypinproc here because its </span><span class="c2"><a class="c9" href="https://www.google.com/url?q=http://pyprocgame.pindev.org/ref-pinproc.html&amp;sa=D&amp;source=editors&amp;ust=1692930752146652&amp;usg=AOvVaw2Gxl3JWfSHtsG6yScRUi7n">documentation</a></span><span class="c1">&nbsp;also contains interesting information, which I tried to summarize above.</span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span>If you know </span><span class="c2"><a class="c9" href="https://www.google.com/url?q=https://github.com/preble/pyprocgame&amp;sa=D&amp;source=editors&amp;ust=1692930752146975&amp;usg=AOvVaw0KMH0-stXEaRSe5Z5hV1xv">pyprocgame</a></span><span>&nbsp;or </span><span class="c2"><a class="c9" href="https://www.google.com/url?q=https://github.com/mjocean/PyProcGameHD-SkeletonGame&amp;sa=D&amp;source=editors&amp;ust=1692930752147176&amp;usg=AOvVaw0oUr4DzuZ-cmeO23N5xlZ2">SkeletonGame</a></span><span class="c1">, the Driver class in gameitems.py is the equivalent of the Driver class in netproc. Here are some differences between the two classes:</span></p><p class="c0"><span class="c1"></span></p><ul class="c14 lst-kix_list_3-0 start"><li class="c3 c4 li-bullet-0"><span class="c1">Some maximum values are lower in Python, presumably because Python does not have unsigned integer types.</span></li><li class="c3 c4 li-bullet-0"><span class="c1">The now argument of patter() and pulsed_patter() does not exist in netproc. It had no effect in Python anyway. The now argument of schedule() exists in both classes and it works in both classes.</span></li><li class="c3 c4 li-bullet-0"><span class="c1">The expression self.game.coils[&quot;coilName&quot;] in Python is equivalent to p3.Coils[&quot;coilName&quot;] in C#</span></li><li class="c3 c4 li-bullet-0"><span class="c1">When the coilName is a literal string, you can access it with self.game.coils.coilName in Python whereas you must use the p3.Coils[&quot;coilName&quot;] syntax in C# in all cases.</span></li></ul></body></html>