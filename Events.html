<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLROjXfSpIU_1TsQlCJ7q4WlXEixY9aqhie8CVYCrTb1E);.lst-kix_list_2-6>li:before{content:"\0025aa   "}.lst-kix_list_2-7>li:before{content:"\0025aa   "}ul.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_2-4>li:before{content:"\0025aa   "}.lst-kix_list_2-5>li:before{content:"\0025aa   "}.lst-kix_list_2-8>li:before{content:"\0025aa   "}.lst-kix_list_3-0>li:before{content:"\0025cf   "}.lst-kix_list_3-1>li:before{content:"o  "}.lst-kix_list_3-2>li:before{content:"\0025aa   "}ul.lst-kix_list_3-7{list-style-type:none}ul.lst-kix_list_3-8{list-style-type:none}ul.lst-kix_list_1-3{list-style-type:none}ul.lst-kix_list_3-1{list-style-type:none}.lst-kix_list_3-5>li:before{content:"\0025aa   "}ul.lst-kix_list_1-4{list-style-type:none}ul.lst-kix_list_3-2{list-style-type:none}ul.lst-kix_list_1-1{list-style-type:none}.lst-kix_list_3-4>li:before{content:"o  "}ul.lst-kix_list_1-2{list-style-type:none}ul.lst-kix_list_3-0{list-style-type:none}ul.lst-kix_list_1-7{list-style-type:none}.lst-kix_list_3-3>li:before{content:"\0025cf   "}ul.lst-kix_list_3-5{list-style-type:none}ul.lst-kix_list_1-8{list-style-type:none}ul.lst-kix_list_3-6{list-style-type:none}ul.lst-kix_list_1-5{list-style-type:none}ul.lst-kix_list_3-3{list-style-type:none}ul.lst-kix_list_1-6{list-style-type:none}ul.lst-kix_list_3-4{list-style-type:none}.lst-kix_list_3-8>li:before{content:"\0025aa   "}.lst-kix_list_3-6>li:before{content:"\0025cf   "}.lst-kix_list_3-7>li:before{content:"o  "}ul.lst-kix_list_2-8{list-style-type:none}ul.lst-kix_list_2-2{list-style-type:none}.lst-kix_list_1-0>li:before{content:"\0025cf   "}ul.lst-kix_list_2-3{list-style-type:none}ul.lst-kix_list_2-0{list-style-type:none}ul.lst-kix_list_2-1{list-style-type:none}ul.lst-kix_list_2-6{list-style-type:none}.lst-kix_list_1-1>li:before{content:"o  "}.lst-kix_list_1-2>li:before{content:"\0025aa   "}ul.lst-kix_list_2-7{list-style-type:none}ul.lst-kix_list_2-4{list-style-type:none}ul.lst-kix_list_2-5{list-style-type:none}.lst-kix_list_1-3>li:before{content:"\0025aa   "}.lst-kix_list_1-4>li:before{content:"\0025aa   "}.lst-kix_list_1-7>li:before{content:"\0025aa   "}.lst-kix_list_1-5>li:before{content:"\0025aa   "}.lst-kix_list_1-6>li:before{content:"\0025aa   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_list_2-0>li:before{content:"\0025cf   "}.lst-kix_list_2-1>li:before{content:"o  "}.lst-kix_list_1-8>li:before{content:"\0025aa   "}.lst-kix_list_2-2>li:before{content:"\0025aa   "}.lst-kix_list_2-3>li:before{content:"\0025aa   "}ol{margin:0;padding:0}table td,table th{padding:0}.c23{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:494.5pt;border-top-color:#000000;border-bottom-style:solid}.c44{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:517.1pt;border-top-color:#000000;border-bottom-style:solid}.c27{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:8pt;line-height:1.0;orphans:2;widows:2;text-align:left;margin-right:-21.1pt}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left;height:11pt}.c33{padding-top:0pt;padding-left:0pt;padding-bottom:8pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c46{padding-top:12pt;padding-bottom:0pt;line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c6{padding-top:2pt;padding-bottom:0pt;line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:8pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left}.c8{padding-top:6pt;padding-bottom:8pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left}.c13{padding-top:12pt;padding-bottom:8pt;line-height:1.0791666666666666;orphans:2;widows:2;text-align:left}.c12{padding-top:6pt;padding-bottom:6pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c9{padding-top:0pt;padding-bottom:6pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c40{padding-top:6pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c20{background-color:#fbfcfd;font-size:10pt;font-family:"Courier New";color:#000000;font-weight:400}.c41{font-weight:400;vertical-align:baseline;font-size:11pt;font-family:"Calibri";font-style:normal}.c37{font-size:8pt;font-family:"Consolas";color:#2b91af;font-weight:400}.c19{border-spacing:0;border-collapse:collapse;margin-right:auto}.c36{color:#2f5496;font-weight:400;font-size:16pt;font-family:"Calibri"}.c4{font-size:9pt;font-family:"Consolas";color:#a31515;font-weight:400}.c1{font-size:8pt;font-family:"Consolas";color:#000000;font-weight:400}.c5{color:#000000;font-weight:400;font-size:11pt;font-family:"Calibri"}.c28{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#0563c1;text-decoration:underline}.c0{font-size:8pt;font-family:"Consolas";color:#0000ff;font-weight:400}.c17{font-size:9pt;font-family:"Consolas";color:#000000;font-weight:400}.c15{color:#a31515;font-weight:400;font-size:8pt;font-family:"Consolas"}.c16{font-size:9pt;font-family:"Consolas";color:#0000ff;font-weight:400}.c25{color:#2f5496;font-weight:400;font-size:13pt;font-family:"Calibri"}.c26{color:#000000;font-weight:400;font-size:8pt;font-family:"Calibri"}.c3{text-decoration:none;vertical-align:baseline;font-style:normal}.c21{font-size:10pt;font-family:"Courier New";font-weight:400}.c34{color:inherit;text-decoration:inherit}.c45{font-weight:400;font-family:"Calibri"}.c31{max-width:495pt;padding:72pt 45pt 72pt 72pt}.c43{padding:0;margin:0}.c24{height:11pt}.c29{background-color:#fbfcfd}.c18{font-style:italic}.c42{text-decoration:none}.c38{text-indent:36pt}.c35{color:#000000}.c32{margin-left:36pt}.c39{margin-right:-29.5pt}.c30{height:0pt}.c22{background-color:#ffffff}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0791666666666666;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Calibri"}p{margin:0;color:#000000;font-size:11pt;font-family:"Calibri"}h1{padding-top:12pt;color:#2f5496;font-size:16pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:2pt;color:#2f5496;font-size:13pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:2pt;color:#1f3863;font-size:12pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0791666666666666;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c22 c31 doc-content"><h1 class="c46"><span class="c3 c36">Events</span></h1><p class="c7"><span class="c41 c42 c35">An event is a way to tell the modes or the GUI that something happened.</span></p><p class="c7"><span>Events are documented in the SDK in </span><span class="c28">file:///C:/P3/P3_SDK_V0.8/P3SampleApp/Documentation/html/_mode_layer.html#ModeEvents</span><span>&nbsp;and </span><span class="c28">file:///C:/P3/P3_SDK_V0.8/P3SampleApp/Documentation/html/_g_u_i_layer.html#GUIEvents</span></p><p class="c7"><span class="c41 c42 c35">This tech tip describes the mode and GUI events with enough implementation details to understand the difference.</span></p><p class="c7"><span class="c41 c42 c35">Switch and timer events are well documented in the SDK guide and there is not much to add. They will not be discussed further here.</span></p><h2 class="c6"><span class="c25 c3">Event Format</span></h2><p class="c7"><span class="c41 c42 c35">An event consists of the event name (string) and the event data (object). The event name is required. The event data is also required, but you can pass null if it is not used.</span></p><p class="c7"><span class="c5 c3">By convention, the event name starts with Evt_ like Evt_BallSaveStart. This is not enforced but it is highly recommended. An event that does not start with Evt_ always feels like an oversight. </span></p><h2 class="c6"><span class="c3 c25">Sending an Event</span></h2><p class="c7"><span class="c5 c3">A mode event is an event sent by a mode. A GUI event is an event sent by the GUI. The two kinds of events have the same form (event name and event data). This is important so I will repeat it. The kind of event is determined by its origin, not by its destination or format.</span></p><p class="c7"><span class="c5 c3">A mode can send a mode event to the modes or to the GUI. To send an event to both the modes and the GUI, two separate calls are needed.</span></p><p class="c14 c32"><span class="c20">PostModeEventToModes(eventName, eventData);</span></p><p class="c7 c32"><span class="c20">PostModeEventToGUI(eventName, eventData);</span></p><p class="c7"><span class="c5 c3">The GUI can only send a GUI event to the modes.</span></p><p class="c7 c38"><span class="c2 c29">PostGUIEventToModes(eventName, eventData);</span></p><p class="c7"><span class="c5 c3">There is no call to send a GUI event to the GUI. In a crunch, you could send a GUI to modes event and send it back as a Mode to GUI event, but that&rsquo;s a hack. Take the time to design a better solution within Unity.</span></p><p class="c7"><span class="c5 c3">The eventName argument is often expressed as a string literal, like &quot;Evt_BallSaveStart&quot;.</span></p><p class="c7"><span class="c5 c3">All three Post methods above return void.</span></p><p class="c7"><span class="c41 c42 c35">The data is the argument of the event. The documentation for an event will say what kind of data is expected by that event. Most events accept a specific data type, but some can even accept a choice of data types.</span></p><p class="c7"><span class="c5 c3">There is only one event data, but that&rsquo;s not a severe limitation. To pass multiple values, it is always possible to define a data class that holds multiple fields. It is also possible to pass an array holding multiple instances of the same data type.</span></p><h2 class="c6"><span class="c25 c3">Mode to Modes Event Handler</span></h2><p class="c7"><span class="c5 c3">To handle an event, a mode must subscribe to the event. The event will be delivered only if the mode is started.</span></p><p class="c7"><span class="c41 c42 c35">It is common to subscribe to an event in the constructor or in mode_started(). These subscriptions are active whenever the mode is active. The subscriptions can also be made at any time to control exactly when the subscription is active.</span></p><p class="c7"><span class="c41 c42 c35">To subscribe to a mode to modes event, the mode must call:</span></p><p class="c7"><span class="c2 c29">AddModeEventHandler(&quot;Evt_ModeEventName&quot;, ModeEventHandler, Priority);</span></p><p class="c7"><span class="c41 c42 c35">Replace Evt_ModeEventName with the name of the event. The call returns void.</span></p><p class="c7"><span class="c5 c3">The event handler method is implemented like this:</span></p><p class="c14"><span class="c2">private bool ModeEventHandler(string eventName, object eventData)</span></p><p class="c14"><span class="c2">{</span></p><p class="c14"><span class="c2">&nbsp; &nbsp;// Cast the event data to the type that is expected</span></p><p class="c14"><span class="c2">&nbsp; int data = (int)eventData;</span></p><p class="c14"><span class="c2">&nbsp; // Do Something</span></p><p class="c14"><span class="c2">&nbsp; // Return EVENT_CONTINUE or EVENT_STOP;</span></p><p class="c14"><span class="c2">&nbsp; return EVENT_CONTINUE;</span></p><p class="c7"><span class="c2">}</span></p><p class="c7"><span>The event handler method can be named anything. It is customary to name it </span><span class="c18">EventName</span><span class="c5 c3">EventHandler without the Evt_ prefix.</span></p><p class="c7"><span class="c5 c3">Return EVENT_CONTINUE to let the event handlers at lower priority be called for this event. Return EVENT_STOP if you don&rsquo;t want the event handlers at lower priority to be called following this event handler. It is preferable to return EVENT_CONTINUE unless you really need to stop the event execution.</span></p><p class="c7"><span class="c41 c42 c35">Sometimes the constant SWITCH_CONTINUE or SWITCH_STOP is returned by an event handler. Those constants have the same value as EVENT_CONTINUE and EVENT_STOP respectively. I find the constants EVENT_CONTINUE and EVENT_STOP to be clearer.</span></p><p class="c7"><span>You can subscribe the event handler at any priority, but in practice, you will always want to use the same priority as the mode. The expression </span><span class="c21">Priority</span><span class="c41 c42 c35">&nbsp;above returns the mode priority though a property getter method.</span></p><p class="c7"><span class="c5 c3">It is possible to register multiple event handlers for the same event. You will likely never do this within a &nbsp;mode class, but it is conceivable a base class registered an event handler for the same event and both will be called (unless stopped with EVENT_STOP).</span></p><h2 class="c6"><span class="c25 c3">GUI to Modes Event Handler</span></h2><p class="c7"><span class="c5 c3">To subscribe to a GUI to mode event, the mode must call:</span></p><p class="c7"><span class="c2 c29">AddGUIEventHandler(&quot;Evt_GUIEventName&quot;, GUIEventHandler);</span></p><p class="c7"><span class="c5 c3">Replace Evt_GUIEventName with the name of the GUI event. The call returns void.</span></p><p class="c7"><span class="c41 c42 c35">The event handler method is implemented like this:</span></p><p class="c14"><span class="c2">private void GUIEventHandler(string eventName, object eventData)</span></p><p class="c14"><span class="c2">{</span></p><p class="c14"><span class="c2">&nbsp; &nbsp;// Cast the event data to the type that is expected</span></p><p class="c14"><span class="c2">&nbsp; bool data = (bool)eventData;</span></p><p class="c14"><span class="c2">&nbsp; // Do Something</span></p><p class="c7"><span class="c2">}</span></p><p class="c7"><span class="c5 c3">Notice AddGUIEventHandler() does not take a priority argument and the GUIEventHandler method returns void. For GUI to mode events, all registered event handlers will be called (for active modes), and the order in which the handlers will be called is unspecified. If you need similar execution behavior than mode to modes events, the obvious solution is to register a single GUI Event handler for a particular GUI event and repost the same or a similar event as a mode to modes event.</span></p><h2 class="c6"><span class="c25 c3">Modes to GUI Event Handler</span></h2><p class="c7"><span class="c3 c5">To receive a mode to GUI event, a GUI script must be a subclass of P3Aware. The script must override the CreateEventHandlers() method and subscribe to the events by calling AddModeEventHandler().</span></p><p class="c14"><span class="c2">protected override void CreateEventHandlers() {</span></p><p class="c14"><span class="c2">&nbsp; // You must call the base class so all parent subscriptions are made</span></p><p class="c14"><span class="c2">&nbsp; base.CreateEventHandlers();</span></p><p class="c14"><span class="c2">&nbsp; AddModeEventHandler(&quot;Evt_ModeToGUIEvent&quot;, ModeToGUIEventHandler);</span></p><p class="c14"><span class="c2">&nbsp; // more AddModeEventHandler() calls here if applicable</span></p><p class="c14"><span class="c2">}</span></p><p class="c14"><span class="c2">&nbsp;</span></p><p class="c14"><span class="c2">public void ModeToGUIEventHandler(string eventName, object eventData) {</span></p><p class="c14"><span class="c2">&nbsp; // Cast the event data to the type that is expected</span></p><p class="c14"><span class="c2">&nbsp; string data = (string)eventData;</span></p><p class="c14"><span class="c2">&nbsp; // Do something.</span></p><p class="c7"><span class="c2">}</span></p><p class="c14"><span>Notice the subscriptions do not take a priority and the event handler returns void. All registered event handlers for this event will be called in an unspecified order.</span></p><p class="c14 c24"><span class="c2"></span></p><h2 class="c6"><span class="c25 c3">Removing Mode Event Handlers</span></h2><p class="c7"><span class="c41 c42 c35">A mode can unsubscribe to an event. The event will no longer be delivered to that mode. </span></p><p class="c14"><span class="c2">RemoveModeEventHandler(&quot;Evt_ModeEventName&quot;, ModeEventHandler);</span></p><p class="c7"><span class="c2 c29">RemoveGUIEventHandler(&quot;Evt_GUIEventName&quot;, GUIEventHandler);</span></p><p class="c8"><span class="c5 c3">This is usually done when the mode must remain active but should not respond to the event anymore.</span></p><p class="c8"><span class="c41 c42 c35">Event subscriptions are automatically removed when the mode is stopped. The subscriptions are remembered and registered again if the mode is restarted. This is what makes it possible to subscribe to events in the mode constructor and not receive the events when the mode is inactive.</span></p><h2 class="c6"><span class="c25 c3">Removing GUI Event Handlers</span></h2><p class="c7"><span class="c5 c3">A GUI script can unsubscribe to an event. The event will no longer be delivered to that script.</span></p><p class="c14"><span class="c2">RemoveModeEventHandler(&quot;Evt_ModeToGUIEvent&quot;, ModeToGUIEventHandler);</span></p><p class="c8"><span class="c41 c42 c35">Event subscriptions are automatically removed when the script is destroyed. A destroyed script cannot be restarted.</span></p><h2 class="c6"><span class="c25 c3">Execution Model</span></h2><p class="c7"><span class="c41 c42 c35">The modes in a P3 application run on the mode thread. The GUI runs on the GUI thread.</span></p><p class="c7"><span class="c5 c3">A mode to modes event is sent and handled on the same thread. This enables synchronous execution. The event is posted by PostModeEventToModes() and the event is fully executed before the call returns. The event is delivered to the modes in priority order. An event handler can let the event propagate to lower priority modes by returning EVENT_CONTINUE, or it can return EVENT_STOP to stop further execution of the event.</span></p><p class="c7"><span class="c5 c3">A mode to GUI event must cross a thread boundary. The mode thread cannot wait for the GUI thread to be available to handle the event. Instead, the mode event is put into a queue which is regularly processed by the GUI thread. It is almost always the case that PostModeEventToGUI() returns before the event is executed. The GUI scripts have no fundamental priority like modes do. For this reason, the event handlers will be called in an unspecified order. If the order is unknown, it is impractical to have a GUI script block further propagation to other GUI scripts. This explains why the mode to GUI event handlers return void and all the subscribed event handlers for the event will be called.</span></p><p class="c7"><span class="c41 c42 c35">A GUI to mode event is the same situation in reverse. The GUI event is put into a queue which is regularly processed by the mode thread. It is almost always the case that PostGUIEventToModes () returns before the event is executed. Here the SDK authors could have chosen to respect the mode priorities. I think they chose not to for symmetry with the mode to GUI events. Therefore, the GUI to mode event handlers return void and all the subscribed event handlers for the event will be called.</span></p><h2 class="c6"><span class="c25 c3">Request and Response Events</span></h2><p class="c7"><span class="c41 c42 c35">It is common for an event to be sent and there is no response to the sender.</span></p><p class="c7"><span class="c5 c3">A request event is a regular event but the sender expects a response in return.</span></p><p class="c7"><span class="c5 c3">This technique works as follows: the sender subscribes to the response event, the sender sends the request event, the request event handler sends a response event with the response value stored in the event data, the original sender handles the response event and extracts the response from the event data. </span></p><p class="c7"><span class="c5 c3">You will likely want to remove the response event handler as soon as the response is received.</span></p><p class="c7"><span class="c5 c3">The documentation of the request event will specify the name of the response event and its event data format. For a mode to modes request event, the response will also be a mode to modes event. For a mode to GUI request event, the response will be a GUI to mode event, and vice-versa.</span></p><p class="c7"><span class="c5 c3">For mode to modes events, the event is handled before PostModeEventToModes() returns. The response will already be available when the call returns. The mode can choose to process the response directly in the response event handler, or it can save the response and process it when the post returns.</span></p><p class="c7"><span class="c41 c42 c35">For mode to GUI or GUI to mode request events, the execution is asynchronous. The post will return before the request event is handled. The response must be handled in the response event handler.</span></p><p class="c7"><span class="c5 c3">There are a few examples of request/response events in the SDK guide. For example, Evt_GameAttributesForServiceMode is the response to Evt_PostGameATtributesForServiceMode, and Evt_CustomLaunchPrepComplete is the response to Evt_CustomLaunchPrep.</span></p><h2 class="c6"><span class="c25 c3">EventManager</span></h2><p class="c8"><span class="c5 c3">The class responsible to deliver mode to modes events is EventManager. A mode should not call the EventManager directly because that by-passes the auto-subscribe/unsubscribe when the mode is started/stopped.</span></p><p class="c8"><span class="c5 c3">A lesser-known fact is that a non-mode class running on the mode thread can also send a mode to modes event by calling the public static method EventManager.Post(). The SDK does this in some cases.</span></p><p class="c8"><span class="c2">EventManager.Post(eventName, eventData);</span></p><p class="c7"><span class="c41 c42 c35">I suspect the non-mode class could even subscribe to an event, but at this point, might as well create a real mode.</span></p><p class="c7"><span class="c41 c35 c42">The class responsible to queue and service the mode to GUI or GUI to mode events is SafeEventManager. The functionality is implemented in instance methods. Static methods would not work because the P3Controller has 3 instances of SafeEventManager that work independently:</span></p><p class="c14"><span class="c2">p3.GUIToModesEventManager</span></p><p class="c14"><span class="c2">p3.ModesToGUIEventManager</span></p><p class="c7"><span class="c2">p3.BallTrackingToGUIEventManager</span></p><p class="c7"><span class="c41 c42 c35">Since SafeEventManager crosses thread boundaries, it must be thread-safe. It should be possible to call it from any thread. It would be interesting to see if the GUI could send events to itself by calling</span></p><p class="c7"><span class="c2">p3.ModesToGUIEventManager.Post(eventName, eventData);</span></p><h2 class="c6"><span class="c25 c3">Event Logging</span></h2><p class="c7"><span class="c5 c3">EventManager and SafeEventManager have a feature to log events that are posted. The logging must be enabled on a per event basis by calling LogEventName():</span></p><p class="c14"><span class="c21">Multimorphic.NetProcMachine.EventManager.LogEventName(&quot;</span><span class="c21 c35">Evt_ModeEventName</span><span class="c2">&quot;, true);</span></p><p class="c14"><span class="c21">p3.ModesToGUIEventManager.LogEventName(&quot;</span><span class="c20">Evt_GUIEventName</span><span class="c2">&quot;, true);</span></p><p class="c7"><span class="c2">p3.GUIToModesEventManager.LogEventName(&quot;Evt_ModeToGUIEvent&quot;, true);</span></p><p class="c7"><span class="c5 c3">The slight syntax difference is because LogEventName() is a static method in EventManager but is an instance method in SafeEventManager.</span></p><p class="c7"><span class="c5 c3">You can also log the ball tracking events if you are interested:</span></p><p class="c7"><span class="c21">p3.BallTrackingToGUIEventManager.LogEventName(eventName, true)</span><span class="c25 c3">;</span></p><p class="c7"><span class="c5 c3">The last argument is true to start logging the specified event, or false to stop logging it.</span></p><p class="c7"><span class="c41 c42 c35">The trace messages will appear in the log with this format:</span></p><p class="c14"><span class="c2">Event: &lt;eventName&gt; posted by: &lt;method&gt;</span></p><p class="c14"><span class="c2">Event: &lt;eventName&gt; received by: &lt;method&gt;</span></p><p class="c14"><span class="c2">New event subscription to &lt;eventName&gt;: &lt;handler&gt;</span></p><p class="c13"><span>The </span><span class="c21">&lt;method&gt;</span><span>&nbsp;following </span><span class="c21">&#39;posted by&#39;</span><span class="c41 c42 c35">&nbsp;is always one of the Post methods (PostModeEventToModes, PostModeEventToGUI, PostGuiEventToModes), indicating the type of event sent. However, to determine where the call was made, you need to examine the stack trace.</span></p><p class="c7"><span>The </span><span class="c21">&lt;method&gt;</span><span>&nbsp;after </span><span class="c21">&#39;received by&#39;</span><span class="c41 c42 c35">&nbsp;precisely indicates where the event was handled. Conversely, the stack trace is generally unhelpful, as it originates from the SDK.</span></p><p class="c7"><span>The </span><span class="c21">&lt;handler&gt;</span><span class="c5 c3">&nbsp;is the name of the method that will be called when the event will be received. The stack trace indicates where the event handler was added.</span></p><p class="c7"><span class="c5 c3">There is a trace message when adding an event handler, but there is no message when removing the handler.</span></p><h2 class="c6"><span class="c25 c3">Obfuscated Event Log</span></h2><p class="c7"><span>If you look in the event log, you will notice the </span><span class="c21">&lt;method&gt;</span><span>&nbsp;is often obfuscated when the sender is within the SDK. Here the token </span><span class="c21">&lt;private&gt;</span><span class="c41 c42 c35">&nbsp;appears as is in the log, it does not represent a variable.</span></p><p class="c7"><span class="c2">Event: Evt_ShowHighScores posted by: &lt;private&gt;</span></p><p class="c7"><span class="c5 c3">This can be defeated with the following code.</span></p><p class="c14"><span class="c2">EventManager.FilterFromLog(&quot;Multimorphic.P3App.&quot;, false);</span></p><p class="c14"><span class="c2">EventManager.FilterFromLog(&quot;Multimorphic.P3.&quot;, false);</span></p><p class="c14"><span class="c2">EventManager.FilterFromLog(&quot;Multimorphic.NetProcMachine.&quot;, false);</span></p><p class="c14"><span class="c2">p3.GUIToModesEventManager.FilterFromLog(&quot;Multimorphic.P3App.&quot;, false);</span></p><p class="c14"><span class="c2">p3.GUIToModesEventManager.FilterFromLog(&quot;Multimorphic.P3.&quot;, false);</span></p><p class="c14"><span class="c2">p3.GUIToModesEventManager.FilterFromLog(&quot;Multimorphic.NetProcMachine.&quot;, false);</span></p><p class="c14"><span class="c2">p3.ModesToGUIEventManager.FilterFromLog(&quot;Multimorphic.P3App.&quot;, false);</span></p><p class="c14"><span class="c2">p3.ModesToGUIEventManager.FilterFromLog(&quot;Multimorphic.P3.&quot;, false);</span></p><p class="c7"><span class="c2">p3.ModesToGUIEventManager.FilterFromLog(&quot;Multimorphic.NetProcMachine.&quot;, false);</span></p><h2 class="c6"><span class="c25 c3">Event Discovery</span></h2><p class="c7"><span class="c5 c3">The event logging feature is great but it has a major drawback. What if you don&rsquo;t know the name of the events you need to debug? There is no option to log every event posted until you can decide which events you truly need.</span></p><p class="c7"><span>This can be solved by patching the Post methods with the help of </span><span class="c28 c22 c45"><a class="c34" href="https://github.com/pardeike/Harmony">Harmony</a></span><span class="c5 c3 c22">.</span></p><p class="c7"><span class="c5 c3 c22">The idea is to decorate the Post methods with a prefix method that enables logging for the event being posted.</span></p><p class="c11"><span class="c5 c3">To install Harmony:</span></p><ul class="c43 lst-kix_list_3-0 start"><li class="c27 li-bullet-0"><span class="c5 c3">Download the pre-compiled library from&nbsp;</span><span class="c28 c41"><a class="c34" href="https://github.com/pardeike/Harmony/releases">GitHub</a></span><span class="c5 c3">. For this tech tip, I downloaded&nbsp;</span><span class="c41 c28"><a class="c34" href="https://github.com/pardeike/Harmony/releases/download/v2.2.2.0/Harmony.2.2.2.0.zip">version 2.2.2.0</a></span></li><li class="c33 c32 li-bullet-0"><span class="c41 c42 c35">Extract the Harmony.2.2.2.0.zip somewhere.</span></li><li class="c32 c33 li-bullet-0"><span class="c41 c42 c35">Copy Harmony.2.2.2.0\net35\0Harmony.dll to P3SampleApp\Assets\Plugins\0Harmony.dll</span></li></ul><p class="c7"><span class="c41 c42 c35">Edit Assets\Scripts\Modes\P3SABaseGameMode.cs</span></p><p class="c7"><span class="c5 c3">Add these statements at the top of the file.</span></p><a id="t.0bf1adaee67a78cb6bdcffe5b23382794e2d9157"></a><a id="t.0"></a><table class="c19"><tr class="c30"><td class="c23" colspan="1" rowspan="1"><p class="c40"><span class="c0">using</span><span class="c1 c3">&nbsp;HarmonyLib;</span></p><p class="c11"><span class="c0">using</span><span class="c1 c3">&nbsp;Multimorphic.NetProcMachine;</span></p><p class="c9"><span class="c0">using</span><span class="c1 c3">&nbsp;Multimorphic.P3.Events;</span></p></td></tr></table><p class="c7 c24"><span class="c41 c42 c35"></span></p><p class="c7"><span class="c41 c42 c35">Add this class immediately after the namespace directive.</span></p><a id="t.013bca1f476fc35f0e9b88c21c9042be582cd5ad"></a><a id="t.1"></a><table class="c19"><tr class="c30"><td class="c23" colspan="1" rowspan="1"><p class="c40"><span class="c1">&nbsp; &nbsp; </span><span class="c0">public</span><span class="c1">&nbsp;</span><span class="c0">class</span><span class="c1">&nbsp;</span><span class="c37">EventManagerPatches</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">public</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;</span><span class="c0">void</span><span class="c1">&nbsp;EventManagerPostPrefix(</span><span class="c0">string</span><span class="c1">&nbsp;eventName, </span><span class="c0">object</span><span class="c1 c3">&nbsp;eventData)</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventManager.LogEventName(eventName, </span><span class="c0">true</span><span class="c1 c3">);</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">public</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;</span><span class="c0">void</span><span class="c1">&nbsp;SafeEventManagerPostPrefix(SafeEventManager __instance, </span><span class="c0">string</span><span class="c1">&nbsp;eventName, </span><span class="c0">object</span><span class="c1 c3">&nbsp;eventData)</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __instance.LogEventName(eventName, </span><span class="c0">true</span><span class="c1 c3">);</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c9"><span class="c1">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c7 c24"><span class="c41 c42 c35"></span></p><p class="c7"><span class="c5 c3">Add this static member declaration before the P3SABaseGameMode constructor.</span></p><a id="t.6711b830d346ed2383ee115f72b832552d8e6655"></a><a id="t.2"></a><table class="c19"><tr class="c30"><td class="c23" colspan="1" rowspan="1"><p class="c12"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">private</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;Harmony harmony;</span></p></td></tr></table><p class="c13"><span class="c41 c42 c35">Add these statements to the P3SABaseGameMode constructor. I couldn&rsquo;t make the Harmony annotations work for some unknown reason, so I chose to Patch() the methods manually.</span></p><a id="t.04c28d936a6ae443d285e44e8f146301f398601e"></a><a id="t.3"></a><table class="c19"><tr class="c30"><td class="c44" colspan="1" rowspan="1"><p class="c40"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; harmony = </span><span class="c16">new</span><span class="c17">&nbsp;Harmony(</span><span class="c4">&quot;com.example.patch&quot;</span><span class="c17 c3">);</span></p><p class="c11"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c16">var</span><span class="c17">&nbsp;eventManagerPost = </span><span class="c16">typeof</span><span class="c17">(EventManager).GetMethod(</span><span class="c4">&quot;Post&quot;</span><span class="c17 c3">);</span></p><p class="c11"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c16">var</span><span class="c17">&nbsp;eventManagerPostPrefix = </span><span class="c16">typeof</span><span class="c17">(EventManagerPatches).GetMethod(</span><span class="c4">&quot;EventManagerPostPrefix&quot;</span><span class="c17 c3">);</span></p><p class="c11"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; harmony.Patch(eventManagerPost, prefix: </span><span class="c16">new</span><span class="c17 c3">&nbsp;HarmonyMethod(eventManagerPostPrefix));</span></p><p class="c10"><span class="c17 c3"></span></p><p class="c11"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c16">var</span><span class="c17">&nbsp;safeEventManagerPost = </span><span class="c16">typeof</span><span class="c17">(SafeEventManager).GetMethod(</span><span class="c4">&quot;Post&quot;</span><span class="c17 c3">);</span></p><p class="c11"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c16">var</span><span class="c17">&nbsp;safeEventManagerPostPrefix = </span><span class="c16">typeof</span><span class="c17">(EventManagerPatches).GetMethod(</span><span class="c4">&quot;SafeEventManagerPostPrefix&quot;</span><span class="c17 c3">);</span></p><p class="c9"><span class="c17">&nbsp; &nbsp; &nbsp; &nbsp; harmony.Patch(safeEventManagerPost, prefix: </span><span class="c16">new</span><span class="c17 c3">&nbsp;HarmonyMethod(safeEventManagerPostPrefix));</span></p></td></tr></table><p class="c13"><span class="c5 c3">Start the application and now every posted event appears in the log.</span></p><p class="c7"><span class="c5 c3">You can get a report by grep&rsquo;ing into the Editor.log</span></p><p class="c7 c39"><span class="c17 c3">&quot;c:\Program Files\Git\usr\bin\grep.exe&quot; &quot;posted by&quot; %USERPROFILE%\AppData\Local\Unity\Editor\Editor.log</span></p><p class="c7"><span class="c41 c42 c35">Once you know the names of the events, you can replace this code with calls to LogEventName().</span></p><h2 class="c6"><span class="c25 c3">Optimizing Event Discovery</span></h2><p class="c7"><span class="c5 c3">The code from the previous section logs every event. This will overburden the system and significantly slow down execution in Unity. You can improve performance by ignoring some high frequency events.</span></p><p class="c7"><span class="c41 c42 c35">Edit Assets\Scripts\Modes\P3SABaseGameMode.cs and replace the EventManagerPatches class with this new implementation:</span></p><a id="t.b5306cd3e5187d7439368140c8b79ad324b8d319"></a><a id="t.4"></a><table class="c19"><tr class="c30"><td class="c23" colspan="1" rowspan="1"><p class="c40"><span class="c1">&nbsp; &nbsp; </span><span class="c0">public</span><span class="c1">&nbsp;</span><span class="c0">class</span><span class="c1">&nbsp;</span><span class="c37">EventManagerPatches</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">private</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;HashSet&lt;</span><span class="c0">string</span><span class="c1">&gt; eventManagerEvents = </span><span class="c0">new</span><span class="c1">&nbsp;HashSet&lt;</span><span class="c0">string</span><span class="c1 c3">&gt;();</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">private</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;Dictionary&lt;SafeEventManager, HashSet&lt;</span><span class="c0">string</span><span class="c1 c3">&gt;&gt; safeEventManagerEvents =</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">new</span><span class="c1">&nbsp;Dictionary&lt;SafeEventManager, HashSet&lt;</span><span class="c0">string</span><span class="c1 c3">&gt;&gt;();</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">private</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;List&lt;</span><span class="c0">string</span><span class="c1">&gt; verboseEvents = </span><span class="c0">new</span><span class="c1">&nbsp;List&lt;</span><span class="c0">string</span><span class="c1 c3">&gt; {</span></p><p class="c11"><span class="c15">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;AccelerometerEvent&quot;</span><span class="c1">, </span><span class="c15">&quot;Grid Event&quot;</span><span class="c1">, </span><span class="c15">&quot;Evt_GUIBurstEvent&quot;</span><span class="c1">, </span><span class="c15">&quot;Evt_GameBurstEvent&quot;</span><span class="c1 c3">,</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c15">&quot;Evt_ShowLocationText&quot;</span><span class="c1">, </span><span class="c15">&quot;Evt_VerticalLevelValue&quot;</span><span class="c1">, </span><span class="c3 c15">&quot;Evt_HorizontalLevelValue&quot;</span></p><p class="c11"><span class="c15">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c3">&nbsp;};</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">private</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;</span><span class="c0">bool</span><span class="c1">&nbsp;isLoggableEvent(</span><span class="c0">string</span><span class="c1 c3">&nbsp;eventName)</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">return</span><span class="c1">&nbsp;!eventName.StartsWith(</span><span class="c15">&quot;Evt_RunGUIInsertCommand&quot;</span><span class="c1 c3">) &amp;&amp;</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !eventName.StartsWith(</span><span class="c15">&quot;Evt_SetLED&quot;</span><span class="c1 c3">) &amp;&amp;</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !eventName.StartsWith(</span><span class="c15">&quot;Evt_AddGUIInsertScript&quot;</span><span class="c1 c3">) &amp;&amp;</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !eventName.StartsWith(</span><span class="c15">&quot;Evt_RemoveGUIInsertScript&quot;</span><span class="c1 c3">) &amp;&amp;</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !eventName.StartsWith(</span><span class="c15">&quot;Evt_AddLEDToSimulator&quot;</span><span class="c1 c3">) &amp;&amp;</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !verboseEvents.Contains(eventName);</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">public</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;</span><span class="c0">void</span><span class="c1">&nbsp;EventManagerPostPrefix(</span><span class="c0">string</span><span class="c1">&nbsp;eventName, </span><span class="c0">object</span><span class="c1 c3">&nbsp;eventData)</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">if</span><span class="c1 c3">&nbsp;(isLoggableEvent(eventName))</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">if</span><span class="c1 c3">&nbsp;(!eventManagerEvents.Contains(eventName))</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eventManagerEvents.Add(eventName);</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventManager.LogEventName(eventName, </span><span class="c0">true</span><span class="c1 c3">);</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">public</span><span class="c1">&nbsp;</span><span class="c0">static</span><span class="c1">&nbsp;</span><span class="c0">void</span><span class="c1">&nbsp;SafeEventManagerPostPrefix(SafeEventManager __instance, </span><span class="c0">string</span><span class="c1">&nbsp;eventName, </span><span class="c0">object</span><span class="c1 c3">&nbsp;eventData)</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">if</span><span class="c1 c3">&nbsp;(!safeEventManagerEvents.ContainsKey(__instance))</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safeEventManagerEvents.Add(__instance, </span><span class="c0">new</span><span class="c1">&nbsp;HashSet&lt;</span><span class="c0">string</span><span class="c1 c3">&gt;());</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c10"><span class="c1 c3"></span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">if</span><span class="c1 c3">&nbsp;(isLoggableEvent(eventName))</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">if</span><span class="c1 c3">&nbsp;(!safeEventManagerEvents[__instance].Contains(eventName))</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safeEventManagerEvents[__instance].Add(eventName);</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __instance.LogEventName(eventName, </span><span class="c0">true</span><span class="c1 c3">);</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c11"><span class="c1 c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c9"><span class="c1">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c7 c24"><span class="c5 c3"></span></p><h2 class="c6"><span class="c25 c3">Special Considerations</span></h2><p class="c7"><span class="c5 c3">Michael Ocean warns us against a common mistake when coding the GUI. When instantiating a prefab with a P3Aware component attached, you cannot send an event to the component immediately. If you do, nothing bad happens but the message will not be delivered to the component. The newly created component did not have time to subscribe to its events because CreateEventHandlers() is called in the Start() method. You have to wait until the component is started, which is likely to happen in the next frame.</span></p><p class="c7"><span class="c5 c3">There is an architecture choice between a permanent event handler in the SceneController or event handlers in individual components. As the number of objects receiving events grows, it is more tempting to distribute the event handling. When considering performance alone, it might be better to handle the events centrally and iterate over the relevant GameObjects.</span></p></body></html>
